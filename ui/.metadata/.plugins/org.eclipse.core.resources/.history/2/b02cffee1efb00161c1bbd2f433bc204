package air.wips.inspect.analyzer.factors;

import java.util.List;

import com.google.gson.Gson;

import air.wips.inspect.result.AirCaptureResult;

public class BusyTimeInspection implements Inspectable {

	/* 차단이 되는 최적의 deauth packet 송출 시간 간격  - time(msec) */
	private double threshold = 100;
	private double busyPercent = 0.0;
	private double busyScore = 0;
	private double busys[];
	private double busyDeltaTimes[]; // 혼잡율 계산을 위한 송신된 패킷의 시간 간격
	
	
	public double inspect(
			double threshold,
			List<AirCaptureResult> captureResults, 
			List<AirCaptureResult> shooterResults) 
					throws NotInspectionDataException 
	{
		this.threshold = threshold;
		if (captureResults.size() == 0) {
			throw new NotInspectionDataException(inspectName());
		}
		
		busyScore = calcBusyTimes(captureResults);
		busyPercent = busyScore / busys.length;
		return busyPercent;
	}
	
	/**
	 * @brief deauth 지연시간 계산 (유실율)
	 * @param captureResults
	 */
	public double calcDelayTimes(List<AirCaptureResult> captureResults) {
		double elapsedTime;
		double prevTime = 0;
		double deltaTime;
		double delayTime;
		int i = 0;
		
		delays = new int[captureResults.size()];
		delayDeltaTimes = new int[captureResults.size()];
		
		for (AirCaptureResult r : captureResults) {
			elapsedTime = Integer.valueOf(r.getElapsed()).intValue();
			
			// delta time = 패킷 수신 시간 - 이전 시간
			delayDeltaTimes[i] = deltaTime = (elapsedTime - prevTime);
			// 기준시간 간격과 지연시간 간격 차이
			delayTime = deltaTime - deltaDeauthMsecThreshold;
			// 지연이 발생하는 경우에만 계산에 포함
			delays[i] = (delayTime > 0) ? delayTime : 0;
			
			delayScore += delays[i];
			
			prevTime = elapsedTime;
			i++;
		}
	}
	
	/**
	 * @brief deauth 잦은시간 계산 (혼잡율)
	 * @param captureResults
	 */
	public void calcBusyTimes(List<AirCaptureResult> captureResults) {
		int elapsedTime;
		int prevTime = 0;
		int deltaTime;
		int busyTime;
		int i = 0;
		
		busys = new int[captureResults.size()];
		busyDeltaTimes = new int[captureResults.size()];
		
		for (AirCaptureResult r : captureResults) {
			elapsedTime = Integer.valueOf(r.getElapsed()).intValue();
			
			// delta time = 패킷 수신 시간 - 이전 시간
			busyDeltaTimes[i] = deltaTime = elapsedTime - prevTime;
			// 기준시간 간격과 잦은시간 간격 차이
			busyTime = deltaTime - deltaDeauthMsecThreshold;
			// 빈번이 발생하는 경우에만 계산에 포함
			busys[i] = (busyTime < 0) ? busyTime : 0;
			
			busyScore += busys[i];
			
			prevTime = elapsedTime;
			i++;
		}
	}

	@Override
	public String analyzeReport() {
		return new Gson().toJson(this);
	}

	@Override
	public String inspectName() {
		return "TimeInspection";
	}

}
